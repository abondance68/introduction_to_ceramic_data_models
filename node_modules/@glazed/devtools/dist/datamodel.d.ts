import type { CeramicApi, CreateOpts, StreamMetadata, UpdateOpts } from '@ceramicnetwork/common';
import { StreamID, StreamRef } from '@ceramicnetwork/streamid';
import { TileDocument } from '@ceramicnetwork/stream-tile';
import type { Definition } from '@glazed/did-datastore-model';
import type { EncodedManagedModel, ManagedEntry, ManagedID, ManagedModel, ManagedSchema, ModelAliases, Schema } from '@glazed/types';
import type { DagJWSResult } from 'dids';
declare type CreateContentType = {
    definition: Definition;
    schema: Schema;
    tile: Record<string, unknown>;
};
declare type UseDeployedIDType = {
    definition: StreamID | string;
    schema: StreamRef | string;
    tile: StreamID | string;
};
/** @internal */
export declare function deployDataStoreSchemas(ceramic: CeramicApi, createOpts?: CreateOpts, commitOpts?: UpdateOpts): Promise<void>;
/** Deploy a managed model to the given Ceramic node. */
export declare function deployModel(ceramic: CeramicApi, model: ManagedModel, createOpts?: CreateOpts, commitOpts?: UpdateOpts): Promise<ModelAliases>;
/**
 * Deploy a {@linkcode types.EncodedManagedModel JSON-encoded managed model} to the given Ceramic
 * node.
 */
export declare function deployEncodedModel(ceramic: CeramicApi, model: EncodedManagedModel): Promise<ModelAliases>;
export declare type ModelManagerConfig = {
    /** Ceramic client instance */
    ceramic: CeramicApi;
    /** Optional {@linkcode types.ManagedModel managed model} to use */
    model?: ManagedModel;
};
export declare type FromJSONParams = {
    /** Ceramic client instance */
    ceramic: CeramicApi;
    /** {@linkcode types.EncodedManagedModel JSON-encoded managed model} to use */
    model: EncodedManagedModel;
};
/**
 * The ModelManager class provides APIs for managing a data model so it can be used at runtime
 * using the {@linkcode datamodel.DataModel DataModel} runtime.
 *
 * The ModelManager class is exported by the {@linkcode devtools} module.
 *
 * ```sh
 * import { ModelManager } from '@glazed/devtools'
 * ```
 */
export declare class ModelManager {
    #private;
    /**
     * Create a ModelManager instance from a
     * {@linkcode types.EncodedManagedModel JSON-encoded managed model}.
     */
    static fromJSON(params: FromJSONParams): ModelManager;
    constructor(config: ModelManagerConfig);
    /** {@linkcode types.ManagedModel Managed model} used internally. */
    get model(): ManagedModel;
    /** Stream IDs of schemas included in the model. */
    get schemas(): Array<string>;
    /** Stream IDs of definitions included in the model. */
    get definitions(): Array<string>;
    /** Stream IDs of tiles included in the model. */
    get tiles(): Array<string>;
    /** @internal */
    _createDoc<T = Record<string, any>>(content: T, metadata?: Partial<StreamMetadata>, opts?: CreateOpts): Promise<TileDocument<T>>;
    /**
     * Add a {@linkcode types.ManagedModel managed model} to the internal model used by the instance.
     */
    addModel(model: ManagedModel): void;
    /**
     * Add a {@linkcode types.EncodedManagedModel JSON-encoded managed model} to the internal model
     * used by the instance.
     */
    addJSONModel(encoded: EncodedManagedModel): void;
    /** Load a stream, ensuring it can be used in a data model. */
    loadStream(streamID: StreamRef | string): Promise<TileDocument>;
    /** @internal */
    _loadAndValidateStream(id: string): Promise<TileDocument>;
    /** Load a stream commits. */
    loadCommits(id: ManagedID): Promise<Array<DagJWSResult>>;
    /** Load a schema stream and other schemas it depends on. */
    loadSchema(id: StreamRef | string, alias?: string): Promise<ManagedID>;
    /** Extract and load a schema's dependencies. */
    loadSchemaDependencies(schema: Schema): Promise<Record<string, Array<string>>>;
    /** Create a new stream of the given type and add it to the managed model. */
    create<T extends keyof CreateContentType, Content = CreateContentType[T]>(type: T, alias: string, content: Content, meta?: Partial<StreamMetadata>): Promise<ManagedID>;
    /**
     * Load an already deployed stream of the given type from the Ceramic node and add it to the
     * managed model.
     */
    useDeployed<T extends keyof UseDeployedIDType, ID = UseDeployedIDType[T]>(type: T, alias: string, id: ID): Promise<ManagedID>;
    /** Get the ID of given schema alias, if present in the model. */
    getSchemaID(alias: string): ManagedID | null;
    hasSchemaAlias(alias: string): boolean;
    /** Get the {@linkcode types.ManagedSchema managed schema} for a given ID. */
    getSchema(id: ManagedID): ManagedSchema | null;
    /** Get the schema commit URL for a given ID. */
    getSchemaURL(id: ManagedID): string | null;
    /** Get the {@linkcode types.ManagedSchema managed schema} for a given alias. */
    getSchemaByAlias(alias: string): ManagedSchema | null;
    /** Create a new schema stream and add it to the managed model. */
    createSchema(alias: string, schema: Schema): Promise<ManagedID>;
    /**
     * Load an already deployed schema stream from the Ceramic node and add it to the managed model.
     */
    useDeployedSchema(alias: string, id: StreamRef | string): Promise<ManagedID>;
    /** Get the ID of given definition alias, if present in the model. */
    getDefinitionID(alias: string): ManagedID | null;
    hasDefinitionAlias(alias: string): boolean;
    /** Get the definition {@linkcode types.ManagedEntry managed entry} for a given ID. */
    getDefinition(id: ManagedID): ManagedEntry | null;
    /** Create a new definition stream and add it to the managed model. */
    createDefinition(alias: string, definition: Definition): Promise<ManagedID>;
    /**
     * Load an already deployed definition stream from the Ceramic node and add it to the managed
     * model.
     */
    useDeployedDefinition(alias: string, id: StreamID | string): Promise<ManagedID>;
    /** Get the ID of given tile alias, if present in the model. */
    getTileID(alias: string): ManagedID | null;
    hasTileAlias(alias: string): boolean;
    /** Get the tile {@linkcode types.ManagedEntry managed entry} for a given ID. */
    getTile(id: ManagedID): ManagedEntry | null;
    /** Create a new tile stream and add it to the managed model. */
    createTile<T extends Record<string, unknown>>(alias: string, contents: T, meta?: Partial<StreamMetadata>): Promise<ManagedID>;
    /**
     * Load an already deployed tile stream from the Ceramic node and add it to the managed model.
     */
    useDeployedTile(alias: string, id: StreamID | string): Promise<ManagedID>;
    /**
     * Deploy the managed model to the Ceramic node and return the {@linkcode types.ModelAliases} to
     * be used by the {@linkcode datamodel.DataModel DataModel} runtime.
     */
    deploy(): Promise<ModelAliases>;
    /**
     * Returns the {@linkcode types.EncodedManagedModel JSON-encoded managed model} so it can be
     * easily stored, shared and reused with the {@linkcode fromJSON} static method.
     */
    toJSON(): EncodedManagedModel;
}
export {};
