function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
import { CommitID, StreamRef } from '@ceramicnetwork/streamid';
import { TileDocument } from '@ceramicnetwork/stream-tile';
import { CIP11_DEFINITION_SCHEMA_URL } from '@glazed/constants';
import { model as encodedDataStoreModel } from '@glazed/did-datastore-model';
import { decodeModel, encodeModel } from './encoding.js';
import { publishCommits } from './publishing.js';
import { extractSchemaReferences } from './schema.js';
function getManagedIDAndVersion(id) {
    const streamID = typeof id === 'string' ? StreamRef.from(id) : id;
    return [
        streamID.baseID.toString(),
        CommitID.isInstance(streamID) ? streamID.toString() : null
    ];
}
function getManagedID(id) {
    const streamID = typeof id === 'string' ? StreamRef.from(id) : id;
    return streamID.baseID.toString();
}
function isSupportedDID(did) {
    return did.startsWith('did:key');
}
function docHasSupportedDID(doc) {
    return isSupportedDID(doc.metadata.controllers[0]);
}
const dataStoreModel = decodeModel(encodedDataStoreModel);
/** @internal */ export async function deployDataStoreSchemas(ceramic, createOpts, commitOpts) {
    await Promise.all(Object.values(dataStoreModel.schemas).map(async (schema)=>{
        return await publishCommits(ceramic, schema.commits, createOpts, commitOpts);
    }));
}
/** Deploy a managed model to the given Ceramic node. */ export async function deployModel(ceramic, model, createOpts, commitOpts) {
    const [schemas] = await Promise.all([
        Promise.all(Object.values(model.schemas).map(async (schema)=>{
            const stream = await publishCommits(ceramic, schema.commits, createOpts, commitOpts);
            return [
                schema.alias,
                stream.commitId.toUrl()
            ];
        })),
        deployDataStoreSchemas(ceramic), 
    ]);
    const [definitions, tiles] = await Promise.all([
        await Promise.all(Object.values(model.definitions).map(async (entry)=>{
            const stream = await publishCommits(ceramic, entry.commits, createOpts, commitOpts);
            return [
                entry.alias,
                stream.id.toString()
            ];
        })),
        await Promise.all(Object.values(model.tiles).map(async (entry)=>{
            const stream = await publishCommits(ceramic, entry.commits, createOpts, commitOpts);
            return [
                entry.alias,
                stream.id.toString()
            ];
        })), 
    ]);
    return {
        definitions: Object.fromEntries(definitions),
        schemas: Object.fromEntries(schemas),
        tiles: Object.fromEntries(tiles)
    };
}
/**
 * Deploy a {@linkcode types.EncodedManagedModel JSON-encoded managed model} to the given Ceramic
 * node.
 */ export async function deployEncodedModel(ceramic, model) {
    return await deployModel(ceramic, decodeModel(model));
}
var _aliases = /*#__PURE__*/ new WeakMap(), _ceramic = /*#__PURE__*/ new WeakMap(), _model = /*#__PURE__*/ new WeakMap(), _referenced = /*#__PURE__*/ new WeakMap(), _streams = /*#__PURE__*/ new WeakMap();
/**
 * The ModelManager class provides APIs for managing a data model so it can be used at runtime
 * using the {@linkcode datamodel.DataModel DataModel} runtime.
 *
 * The ModelManager class is exported by the {@linkcode devtools} module.
 *
 * ```sh
 * import { ModelManager } from '@glazed/devtools'
 * ```
 */ export class ModelManager {
    /**
   * Create a ModelManager instance from a
   * {@linkcode types.EncodedManagedModel JSON-encoded managed model}.
   */ static fromJSON(params) {
        return new ModelManager({
            ceramic: params.ceramic,
            model: decodeModel(params.model)
        });
    }
    // Getters
    /** {@linkcode types.ManagedModel Managed model} used internally. */ get model() {
        return _classPrivateFieldGet(this, _model);
    }
    /** Stream IDs of schemas included in the model. */ get schemas() {
        return Object.keys(_classPrivateFieldGet(this, _aliases).schemas).sort();
    }
    /** Stream IDs of definitions included in the model. */ get definitions() {
        return Object.keys(_classPrivateFieldGet(this, _aliases).definitions).sort();
    }
    /** Stream IDs of tiles included in the model. */ get tiles() {
        return Object.keys(_classPrivateFieldGet(this, _aliases).tiles).sort();
    }
    // Internal
    /** @internal */ async _createDoc(content, metadata = {}, opts = {
        anchor: false,
        pin: true
    }) {
        return await TileDocument.create(_classPrivateFieldGet(this, _ceramic), content, metadata, opts);
    }
    // Imports
    /**
   * Add a {@linkcode types.ManagedModel managed model} to the internal model used by the instance.
   */ addModel(model) {
        Object.assign(_classPrivateFieldGet(this, _model).definitions, model.definitions);
        Object.assign(_classPrivateFieldGet(this, _model).schemas, model.schemas);
        Object.assign(_classPrivateFieldGet(this, _model).tiles, model.tiles);
        for (const [id, schema] of Object.entries(model.schemas)){
            _classPrivateFieldGet(this, _aliases).schemas[schema.alias] = id;
            for (const refIDs of Object.values(schema.dependencies)){
                for (const refID of refIDs){
                    if (_classPrivateFieldGet(this, _referenced)[refID] == null) {
                        _classPrivateFieldGet(this, _referenced)[refID] = {
                            definitions: new Set(),
                            schemas: new Set(),
                            tiles: new Set()
                        };
                    }
                    _classPrivateFieldGet(this, _referenced)[refID].schemas.add(id);
                }
            }
        }
        for (const [id1, definition] of Object.entries(model.definitions)){
            _classPrivateFieldGet(this, _aliases).definitions[definition.alias] = id1;
            if (_classPrivateFieldGet(this, _referenced)[definition.schema] == null) {
                _classPrivateFieldGet(this, _referenced)[definition.schema] = {
                    definitions: new Set(),
                    schemas: new Set(),
                    tiles: new Set()
                };
            }
            _classPrivateFieldGet(this, _referenced)[definition.schema].definitions.add(id1);
        }
        for (const [id2, tile] of Object.entries(model.tiles)){
            _classPrivateFieldGet(this, _aliases).tiles[tile.alias] = id2;
            if (_classPrivateFieldGet(this, _referenced)[tile.schema] == null) {
                _classPrivateFieldGet(this, _referenced)[tile.schema] = {
                    definitions: new Set(),
                    schemas: new Set(),
                    tiles: new Set()
                };
            }
            _classPrivateFieldGet(this, _referenced)[tile.schema].tiles.add(id2);
        }
    }
    /**
   * Add a {@linkcode types.EncodedManagedModel JSON-encoded managed model} to the internal model
   * used by the instance.
   */ addJSONModel(encoded) {
        this.addModel(decodeModel(encoded));
    }
    // Loaders
    /** Load a stream, ensuring it can be used in a data model. */ async loadStream(streamID) {
        const id = typeof streamID === 'string' ? streamID : streamID.baseID.toString();
        if (_classPrivateFieldGet(this, _streams)[id] == null) {
            _classPrivateFieldGet(this, _streams)[id] = this._loadAndValidateStream(id);
        }
        return await _classPrivateFieldGet(this, _streams)[id];
    }
    /** @internal */ async _loadAndValidateStream(id) {
        const stream = await TileDocument.load(_classPrivateFieldGet(this, _ceramic), id);
        if (stream.anchorCommitIds.length !== 0) {
            throw new Error(`Invalid stream ${id}: contains anchor commit`);
        }
        // Shortcut logic for single commit
        if (stream.allCommitIds.length === 1 && docHasSupportedDID(stream)) {
            return stream;
        }
        const commits = await Promise.all(stream.allCommitIds.map(async (commitID)=>{
            return await TileDocument.load(_classPrivateFieldGet(this, _ceramic), commitID);
        }));
        const unsupported = commits.find((commit)=>!docHasSupportedDID(commit)
        );
        if (unsupported != null) {
            throw new Error(`Invalid stream ${id}: contains a commit authored by an unsupported DID`);
        }
        return stream;
    }
    /** Load a stream commits. */ async loadCommits(id) {
        const commits = await _classPrivateFieldGet(this, _ceramic).loadStreamCommits(id);
        return commits.map((r)=>r.value
        );
    }
    /** Load a schema stream and other schemas it depends on. */ async loadSchema(id, alias) {
        const [managedID, commitID] = getManagedIDAndVersion(id);
        if (commitID === null) {
            throw new Error(`Expected CommitID to load schema: ${managedID}`);
        }
        const existing = _classPrivateFieldGet(this, _model).schemas[managedID];
        if (existing != null) {
            if (existing.version !== commitID) {
                throw new Error(`Another version for this schema is already set: ${existing.version}`);
            }
            if (alias != null && existing.alias !== alias) {
                throw new Error(`Another alias for this schema is already set: ${existing.alias}`);
            }
            return managedID;
        }
        const [stream, commits] = await Promise.all([
            this.loadStream(commitID),
            this.loadCommits(managedID), 
        ]);
        const content = stream.content ?? {};
        const name = alias ?? content.title;
        if (name == null) {
            throw new Error('Schema must have a title property or an alias must be provided');
        }
        const dependencies = await this.loadSchemaDependencies(content);
        _classPrivateFieldGet(this, _model).schemas[managedID] = {
            alias: name,
            commits,
            dependencies,
            version: commitID
        };
        _classPrivateFieldGet(this, _aliases).schemas[name] = managedID;
        return managedID;
    }
    /** Extract and load a schema's dependencies. */ async loadSchemaDependencies(schema) {
        const references = extractSchemaReferences(schema);
        const ids = new Set();
        for (const refs of Object.values(references)){
            for (const ref of refs){
                ids.add(ref);
            }
        }
        const loaded = await Promise.all(Array.from(ids).map(async (id)=>[
                id,
                await this.loadSchema(id)
            ]
        ));
        const idToManaged = Object.fromEntries(loaded);
        return Object.entries(references).reduce((acc, [path, deps])=>{
            acc[path] = deps.map((id)=>idToManaged[id]
            );
            return acc;
        }, {});
    }
    // High-level
    /** Create a new stream of the given type and add it to the managed model. */ async create(type, alias, content, meta) {
        switch(type){
            case 'schema':
                return await this.createSchema(alias, content);
            case 'definition':
                return await this.createDefinition(alias, content);
            case 'tile':
                return await this.createTile(alias, content, meta);
            default:
                throw new Error(`Unsupported type: ${type}`);
        }
    }
    /**
   * Load an already deployed stream of the given type from the Ceramic node and add it to the
   * managed model.
   */ async useDeployed(type, alias, id) {
        switch(type){
            case 'schema':
                return await this.useDeployedSchema(alias, id);
            case 'definition':
                return await this.useDeployedDefinition(alias, id);
            case 'tile':
                return await this.useDeployedTile(alias, id);
            default:
                throw new Error(`Unsupported type: ${type}`);
        }
    }
    // Schemas
    /** Get the ID of given schema alias, if present in the model. */ getSchemaID(alias) {
        return _classPrivateFieldGet(this, _aliases).schemas[alias] ?? null;
    }
    hasSchemaAlias(alias) {
        return this.getSchemaID(alias) != null;
    }
    /** Get the {@linkcode types.ManagedSchema managed schema} for a given ID. */ getSchema(id) {
        return _classPrivateFieldGet(this, _model).schemas[id] ?? null;
    }
    /** Get the schema commit URL for a given ID. */ getSchemaURL(id) {
        const schema = _classPrivateFieldGet(this, _model).schemas[id];
        return schema ? CommitID.fromString(schema.version).toUrl() : null;
    }
    /** Get the {@linkcode types.ManagedSchema managed schema} for a given alias. */ getSchemaByAlias(alias) {
        const id = this.getSchemaID(alias);
        return id ? this.getSchema(id) : null;
    }
    /** Create a new schema stream and add it to the managed model. */ async createSchema(alias, schema) {
        if (_classPrivateFieldGet(this, _ceramic).did == null || !_classPrivateFieldGet(this, _ceramic).did.authenticated) {
            throw new Error('Ceramic instance must be authenticated');
        }
        if (!isSupportedDID(_classPrivateFieldGet(this, _ceramic).did.id)) {
            throw new Error(`Invalid DID ${_classPrivateFieldGet(this, _ceramic).did.id} to create stream for model, only "did:key" is supported`);
        }
        if (this.hasSchemaAlias(alias)) {
            throw new Error(`Schema ${alias} already exists`);
        }
        const [stream, dependencies] = await Promise.all([
            this._createDoc(schema),
            this.loadSchemaDependencies(schema), 
        ]);
        const id = stream.id.toString();
        _classPrivateFieldGet(this, _model).schemas[id] = {
            alias,
            commits: await this.loadCommits(id),
            dependencies,
            version: stream.commitId.toString()
        };
        _classPrivateFieldGet(this, _aliases).schemas[alias] = id;
        return id;
    }
    /**
   * Load an already deployed schema stream from the Ceramic node and add it to the managed model.
   */ async useDeployedSchema(alias, id) {
        if (alias == null) {
            throw new Error('Schema alias must be provided');
        }
        return await this.loadSchema(id, alias);
    }
    // Definitions
    /** Get the ID of given definition alias, if present in the model. */ getDefinitionID(alias) {
        return _classPrivateFieldGet(this, _aliases).definitions[alias] ?? null;
    }
    hasDefinitionAlias(alias) {
        return this.getDefinitionID(alias) != null;
    }
    /** Get the definition {@linkcode types.ManagedEntry managed entry} for a given ID. */ getDefinition(id) {
        return _classPrivateFieldGet(this, _model).definitions[id] ?? null;
    }
    /** Create a new definition stream and add it to the managed model. */ async createDefinition(alias, definition) {
        if (_classPrivateFieldGet(this, _ceramic).did == null || !_classPrivateFieldGet(this, _ceramic).did.authenticated) {
            throw new Error('Ceramic instance must be authenticated');
        }
        if (!isSupportedDID(_classPrivateFieldGet(this, _ceramic).did.id)) {
            throw new Error(`Invalid DID ${_classPrivateFieldGet(this, _ceramic).did.id} to create stream for model, only "did:key" is supported`);
        }
        if (this.hasDefinitionAlias(alias)) {
            throw new Error(`Definition ${alias} already exists`);
        }
        await deployDataStoreSchemas(_classPrivateFieldGet(this, _ceramic));
        const [stream, schemaID] = await Promise.all([
            this._createDoc(definition, {
                schema: CIP11_DEFINITION_SCHEMA_URL
            }),
            this.loadSchema(definition.schema), 
        ]);
        const id = stream.id.toString();
        _classPrivateFieldGet(this, _model).definitions[id] = {
            alias,
            commits: await this.loadCommits(id),
            schema: schemaID,
            version: stream.commitId.toString()
        };
        _classPrivateFieldGet(this, _aliases).definitions[alias] = id;
        return id;
    }
    /**
   * Load an already deployed definition stream from the Ceramic node and add it to the managed
   * model.
   */ async useDeployedDefinition(alias, id) {
        if (this.hasDefinitionAlias(alias)) {
            throw new Error(`Definition ${alias} already exists`);
        }
        const definitionID = getManagedID(id);
        const [stream, commits] = await Promise.all([
            this.loadStream(id),
            this.loadCommits(definitionID), 
        ]);
        _classPrivateFieldGet(this, _model).definitions[definitionID] = {
            alias,
            commits,
            schema: await this.loadSchema(stream.content.schema),
            version: stream.commitId.toString()
        };
        _classPrivateFieldGet(this, _aliases).definitions[alias] = definitionID;
        return definitionID;
    }
    // Tiles
    /** Get the ID of given tile alias, if present in the model. */ getTileID(alias) {
        return _classPrivateFieldGet(this, _aliases).tiles[alias] ?? null;
    }
    hasTileAlias(alias) {
        return this.getTileID(alias) != null;
    }
    /** Get the tile {@linkcode types.ManagedEntry managed entry} for a given ID. */ getTile(id) {
        return _classPrivateFieldGet(this, _model).tiles[id] ?? null;
    }
    /** Create a new tile stream and add it to the managed model. */ async createTile(alias, contents, meta = {}) {
        if (_classPrivateFieldGet(this, _ceramic).did == null || !_classPrivateFieldGet(this, _ceramic).did.authenticated) {
            throw new Error('Ceramic instance must be authenticated');
        }
        if (!isSupportedDID(_classPrivateFieldGet(this, _ceramic).did.id)) {
            throw new Error('Unsupported DID to create stream for model');
        }
        if (this.hasTileAlias(alias)) {
            throw new Error(`Tile ${alias} already exists`);
        }
        if (meta.schema == null) {
            throw new Error(`Missing schema to create tile ${alias}`);
        }
        const [stream, schemaID] = await Promise.all([
            this._createDoc(contents, meta),
            this.loadSchema(meta.schema), 
        ]);
        const id = stream.id.toString();
        _classPrivateFieldGet(this, _model).tiles[id] = {
            alias,
            commits: await this.loadCommits(id),
            schema: schemaID,
            version: stream.commitId.toString()
        };
        _classPrivateFieldGet(this, _aliases).tiles[alias] = id;
        return id;
    }
    /**
   * Load an already deployed tile stream from the Ceramic node and add it to the managed model.
   */ async useDeployedTile(alias, id) {
        if (this.hasTileAlias(alias)) {
            throw new Error(`Tile ${alias} already exists`);
        }
        const tileID = getManagedID(id);
        const [stream, commits] = await Promise.all([
            this.loadStream(id),
            this.loadCommits(tileID)
        ]);
        if (stream.metadata.schema == null) {
            throw new Error('Loaded tile has no schema defined');
        }
        _classPrivateFieldGet(this, _model).tiles[tileID] = {
            alias,
            commits,
            schema: await this.loadSchema(stream.metadata.schema),
            version: stream.commitId.toString()
        };
        _classPrivateFieldGet(this, _aliases).tiles[alias] = tileID;
        return tileID;
    }
    // Exports
    /**
   * Deploy the managed model to the Ceramic node and return the {@linkcode types.ModelAliases} to
   * be used by the {@linkcode datamodel.DataModel DataModel} runtime.
   */ async deploy() {
        return await deployModel(_classPrivateFieldGet(this, _ceramic), _classPrivateFieldGet(this, _model));
    }
    /**
   * Returns the {@linkcode types.EncodedManagedModel JSON-encoded managed model} so it can be
   * easily stored, shared and reused with the {@linkcode fromJSON} static method.
   */ toJSON() {
        return encodeModel(_classPrivateFieldGet(this, _model));
    }
    constructor(config){
        _classPrivateFieldInit(this, _aliases, {
            writable: true,
            value: {
                definitions: {},
                schemas: {},
                tiles: {}
            }
        });
        _classPrivateFieldInit(this, _ceramic, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _model, {
            writable: true,
            value: {
                definitions: {},
                schemas: {},
                tiles: {}
            }
        });
        _classPrivateFieldInit(this, _referenced, {
            writable: true,
            value: {}
        });
        _classPrivateFieldInit(this, _streams, {
            writable: true,
            value: {}
        });
        _classPrivateFieldSet(this, _ceramic, config.ceramic);
        if (config.model != null) {
            this.addModel(config.model);
        }
    }
}
